
class Powcaptcha{static tmpFolder=process?.env?.POWCAPTCHA_TMPFOLDER;static crypto;static async createChallenge(puzzles=50){const crypto=this.getCrypto();const arr=[];for(let i=0;i<puzzles;i++){arr.push(this.byteArrayToHex(crypto.getRandomValues(new Uint8Array(16))));}
return arr.join('');}
static async verifySolution(challengeString,solution,difficulty=4){if(!challengeString||challengeString.length<32||(challengeString.length%32)){throw new Error('Invalid challenge string');}
const challenges=challengeString.length/32;const lengthPerSolution=difficulty+2;const solutionLengthRequired=challenges*lengthPerSolution;if(!solution||solution.length!==solutionLengthRequired){throw new Error('Invalid solution');}
const enc=new TextEncoder();const fs=require('fs');const challengeHash=await this.hash(enc.encode(challengeString));const hashFile=this.tmpFolder+'/'+challengeHash+'.pow';if(fs.existsSync(hashFile)){return false;}
const threshold=Math.pow(10,10-difficulty);for(let i=0;i<challenges;i++){const iteration=solution.substring(i*lengthPerSolution,i*lengthPerSolution+lengthPerSolution);const challenge=challengeString.substring(i*32,i*32+32);const hash=await this.hash(enc.encode(challenge+iteration));const value=(new Uint32Array(this.hexToByteArray(hash.substring(0,8)).buffer))[0];if(value<=threshold){continue;}
return false;}
if(!this.tmpFolder||!fs.existsSync(this.tmpFolder)||!fs.lstatSync(this.tmpFolder).isDirectory()){throw new Error('Cannot find tmpFolder for Powcaptcha');}
const timeThreshold=new Date().getTime()-(300*1000);for(const file of fs.readdirSync(this.tmpFolder)){const path=this.tmpFolder+'/'+file;if(file.endsWith('.pow')&&fs.lstatSync(path).mtime.getTime()<timeThreshold){fs.unlinkSync(path);}}
fs.writeFileSync(hashFile,'');return true;}
static async solveChallenge(challengeString,difficulty=4,progressHandler=null){if(difficulty<1||difficulty>7){throw new Error('Difficulty need to be between 1-7');}
if(!challengeString||challengeString.length<32||(challengeString.length%32)){throw new Error('Invalid challenge string');}
const challenges=challengeString.length/32;const enc=new TextEncoder();const solutions=[];const threshold=Math.pow(10,10-difficulty);for(let i=0;i<challenges;i++){let iteration=Math.pow(10,difficulty+1);const challenge=challengeString.substring(i*32,i*32+32);while(true){const hashPart=await this.getCrypto().subtle.digest('SHA-256',enc.encode(challenge+iteration));const value=(new Uint32Array(hashPart))[0];if(value<=threshold){if(progressHandler){progressHandler(1/challenges*(i+1));}
solutions.push(iteration);break;}
iteration++;}}
return solutions.join('');}
static getCrypto(){if(typeof this.crypto!=='undefined'){return this.crypto;}
if(typeof Uint8Array==='undefined'){throw new Error('Unsupported environment, Uint8Array missing');}
if(typeof TextEncoder==='undefined'){throw new Error('Unsupported environment, TextEncoder missing');}
if(typeof window==='undefined'){if(typeof module!=='undefined'&&module.exports){this.crypto=require('crypto').webcrypto;return this.crypto;}
if(typeof self!=='undefined'&&self.crypto){this.crypto=self.crypto;return this.crypto;}}
if(!window.crypto){throw new Error('Unsupported environment, crypto missing');}
this.crypto=window.crypto;return this.crypto;}
static async hash(data){return this.byteArrayToHex(new Uint8Array(await this.getCrypto().subtle.digest('SHA-256',data)));}
static byteArrayToHex(byteArray){return Array.from(byteArray).map(x=>x.toString(16).padStart(2,'0')).join('');}
static hexToByteArray(str){return Uint8Array.from((str.match(/.{1,2}/g)||[]).map((byte)=>parseInt(byte,16)));}}
if(typeof module!=='undefined'&&module.exports){module.exports=Powcaptcha}